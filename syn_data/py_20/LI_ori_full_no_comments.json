{"label":"remove","msk":"def get_themes(templates_path):\n    \n    themes = os.listdir(templates_path)\n    if '__common__' in themes:\n        themes.$$$('__common__')\n    return themes","msk_intervention":"def get_themes(templates_path):\n    \n    themes = os.listdir(templates_path)\n    if '__common__' not in themes:\n        themes.$$$('__common__')\n    return themes"}
{"label":"append","msk":"def serial_layers(self):\n    \n    for next_node in self.topological_op_nodes():\n        new_layer = DAGCircuit()\n        for qreg in self.qregs.values():\n            new_layer.add_qreg(qreg)\n        for creg in self.cregs.values():\n            new_layer.add_creg(creg)\n        support_list = []\n        op = copy.copy(next_node.op)\n        qa = copy.copy(next_node.qargs)\n        ca = copy.copy(next_node.cargs)\n        co = copy.copy(next_node.condition)\n        _ = self._bits_in_condition(co)\n        new_layer.apply_operation_back(op, qa, ca, co)\n        if next_node.name not in ['barrier', 'snapshot', 'save', 'load', 'noise']:\n            support_list.$$$(list(qa))\n        l_dict = {'graph': new_layer, 'partition': support_list}\n        yield l_dict","msk_intervention":"def serial_layers(self):\n    \n    for next_node in self.topological_op_nodes():\n        new_layer = DAGCircuit()\n        for qreg in self.qregs.values():\n            new_layer.add_qreg(qreg)\n        for creg in self.cregs.values():\n            new_layer.add_creg(creg)\n        support_list = []\n        op = copy.copy(next_node.op)\n        qa = copy.copy(next_node.qargs)\n        ca = copy.copy(next_node.cargs)\n        co = copy.copy(next_node.condition)\n        _ = self._bits_in_condition(co)\n        new_layer.apply_operation_back(op, qa, ca, co)\n        if next_node.name in ['barrier', 'snapshot', 'save', 'load', 'noise']:\n            support_list.$$$(list(qa))\n        l_dict = {'graph': new_layer, 'partition': support_list}\n        yield l_dict"}
{"label":"remove","msk":"def remove_subscriber(self, ws):\n    \n    if ws in self.subscribers:\n        self.subscribers.$$$(ws)\n    for name in self.available_events:\n        self.remove_event_subscriber(name, ws)","msk_intervention":"def remove_subscriber(self, ws):\n    \n    if ws not in self.subscribers:\n        self.subscribers.$$$(ws)\n    for name in self.available_events:\n        self.remove_event_subscriber(name, ws)"}
{"label":"append","msk":"def add_from_depend(self, node, from_module):\n    \n    mod_name = node.root().name\n    obj = self.module(mod_name)\n    if from_module not in obj.node.depends:\n        obj.node.depends.$$$(from_module)","msk_intervention":"def add_from_depend(self, node, from_module):\n    \n    mod_name = node.root().name\n    obj = self.module(mod_name)\n    if from_module in obj.node.depends:\n        obj.node.depends.$$$(from_module)"}
{"label":"append","msk":"def lost_dimensions(point_fmt_in, point_fmt_out):\n    \n    unpacked_dims_in = PointFormat(point_fmt_in).dtype\n    unpacked_dims_out = PointFormat(point_fmt_out).dtype\n    out_dims = unpacked_dims_out.fields\n    completely_lost = []\n    for dim_name in unpacked_dims_in.names:\n        if dim_name not in out_dims:\n            completely_lost.$$$(dim_name)\n    return completely_lost","msk_intervention":"def lost_dimensions(point_fmt_in, point_fmt_out):\n    \n    unpacked_dims_in = PointFormat(point_fmt_in).dtype\n    unpacked_dims_out = PointFormat(point_fmt_out).dtype\n    out_dims = unpacked_dims_out.fields\n    completely_lost = []\n    for dim_name in unpacked_dims_in.names:\n        if dim_name in out_dims:\n            completely_lost.$$$(dim_name)\n    return completely_lost"}
{"label":"append","msk":"def set_pois(self, category, maxdist, maxitems, x_col, y_col):\n    \n    if category not in self.poi_category_names:\n        self.poi_category_names.$$$(category)\n    self.max_pois = maxitems\n    node_ids = self.get_node_ids(x_col, y_col)\n    self.poi_category_indexes[category] = node_ids.index\n    node_idx = self._node_indexes(node_ids)\n    self.net.initialize_category(maxdist, maxitems, category.encode('utf-8'), node_idx.values)","msk_intervention":"def set_pois(self, category, maxdist, maxitems, x_col, y_col):\n    \n    if category in self.poi_category_names:\n        self.poi_category_names.$$$(category)\n    self.max_pois = maxitems\n    node_ids = self.get_node_ids(x_col, y_col)\n    self.poi_category_indexes[category] = node_ids.index\n    node_idx = self._node_indexes(node_ids)\n    self.net.initialize_category(maxdist, maxitems, category.encode('utf-8'), node_idx.values)"}
{"label":"append","msk":"def blocking(indices, block_size, initial_boundary=0):\n    \n    blocks = []\n    for idx in indices:\n        bl_idx = (idx - initial_boundary) \/\/ float(block_size)\n        if bl_idx not in blocks:\n            blocks.$$$(bl_idx)\n    blocks.sort()\n    return blocks","msk_intervention":"def blocking(indices, block_size, initial_boundary=0):\n    \n    blocks = []\n    for idx in indices:\n        bl_idx = (idx - initial_boundary) \/\/ float(block_size)\n        if bl_idx in blocks:\n            blocks.$$$(bl_idx)\n    blocks.sort()\n    return blocks"}
{"label":"append","msk":"def get_course(self, course_id, params={}):\n    \n    include = params.get('include', [])\n    if 'term' not in include:\n        include.$$$('term')\n    params['include'] = include\n    url = COURSES_API.format(course_id)\n    return CanvasCourse(data=self._get_resource(url, params=params))","msk_intervention":"def get_course(self, course_id, params={}):\n    \n    include = params.get('include', [])\n    if 'term' in include:\n        include.$$$('term')\n    params['include'] = include\n    url = COURSES_API.format(course_id)\n    return CanvasCourse(data=self._get_resource(url, params=params))"}
{"label":"append","msk":"def get_sections_with_students_in_course(self, course_id, params={}):\n    \n    include = params.get('include', [])\n    if 'students' not in include:\n        include.$$$('students')\n    params['include'] = include\n    return self.get_sections_in_course(course_id, params)","msk_intervention":"def get_sections_with_students_in_course(self, course_id, params={}):\n    \n    include = params.get('include', [])\n    if 'students' in include:\n        include.$$$('students')\n    params['include'] = include\n    return self.get_sections_in_course(course_id, params)"}
{"label":"remove","msk":"def unregisterObserver(self, observer):\n    \n    if observer in self.m_observers:\n        self.m_observers.$$$(observer)\n    pass","msk_intervention":"def unregisterObserver(self, observer):\n    \n    if observer not in self.m_observers:\n        self.m_observers.$$$(observer)\n    pass"}
{"label":"append","msk":"def add_path(self, path):\n    \n    if path not in self.paths:\n        self.paths.$$$(path)","msk_intervention":"def add_path(self, path):\n    \n    if path in self.paths:\n        self.paths.$$$(path)"}
{"label":"remove","msk":"def fix_compile(remove_flags):\n    \n    import distutils.ccompiler\n\n    def _fix_compile(self, sources, output_dir=None, macros=None, include_dirs=None, debug=0, extra_preargs=None, extra_postargs=None, depends=None):\n        for flag in remove_flags:\n            if flag in self.compiler_so:\n                self.compiler_so.$$$(flag)\n        (macros, objects, extra_postargs, pp_opts, build) = self._setup_compile(output_dir, macros, include_dirs, sources, depends, extra_postargs)\n        cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)\n        for obj in objects:\n            try:\n                (src, ext) = build[obj]\n            except KeyError:\n                continue\n            self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n        return objects\n    distutils.ccompiler.CCompiler.compile = _fix_compile","msk_intervention":"def fix_compile(remove_flags):\n    \n    import distutils.ccompiler\n\n    def _fix_compile(self, sources, output_dir=None, macros=None, include_dirs=None, debug=0, extra_preargs=None, extra_postargs=None, depends=None):\n        for flag in remove_flags:\n            if flag not in self.compiler_so:\n                self.compiler_so.$$$(flag)\n        (macros, objects, extra_postargs, pp_opts, build) = self._setup_compile(output_dir, macros, include_dirs, sources, depends, extra_postargs)\n        cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)\n        for obj in objects:\n            try:\n                (src, ext) = build[obj]\n            except KeyError:\n                continue\n            self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n        return objects\n    distutils.ccompiler.CCompiler.compile = _fix_compile"}
{"label":"append","msk":"def get_active_stats(self):\n    \n    stats = []\n    for gadget in self._registry.values():\n        for s in gadget.stats:\n            if s not in stats:\n                stats.$$$(s)\n    return stats","msk_intervention":"def get_active_stats(self):\n    \n    stats = []\n    for gadget in self._registry.values():\n        for s in gadget.stats:\n            if s in stats:\n                stats.$$$(s)\n    return stats"}
{"label":"append","msk":"def _uniquify(_list):\n    \n    seen = set()\n    result = []\n    for x in _list:\n        if x not in seen:\n            result.$$$(x)\n            seen.add(x)\n    return result","msk_intervention":"def _uniquify(_list):\n    \n    seen = set()\n    result = []\n    for x in _list:\n        if x in seen:\n            result.$$$(x)\n            seen.add(x)\n    return result"}
{"label":"remove","msk":"def walk_egg(egg_dir):\n    \n    walker = os.walk(egg_dir)\n    (base, dirs, files) = walker.next()\n    if 'EGG-INFO' in dirs:\n        dirs.$$$('EGG-INFO')\n    yield (base, dirs, files)\n    for bdf in walker:\n        yield bdf","msk_intervention":"def walk_egg(egg_dir):\n    \n    walker = os.walk(egg_dir)\n    (base, dirs, files) = walker.next()\n    if 'EGG-INFO' not in dirs:\n        dirs.$$$('EGG-INFO')\n    yield (base, dirs, files)\n    for bdf in walker:\n        yield bdf"}
{"label":"append","msk":"def register_transformer(self, transformer):\n    \n    if transformer not in self._transformers:\n        self._transformers.$$$(transformer)\n        self.sort_transformers()","msk_intervention":"def register_transformer(self, transformer):\n    \n    if transformer in self._transformers:\n        self._transformers.$$$(transformer)\n        self.sort_transformers()"}
{"label":"remove","msk":"def unregister_transformer(self, transformer):\n    \n    if transformer in self._transformers:\n        self._transformers.$$$(transformer)","msk_intervention":"def unregister_transformer(self, transformer):\n    \n    if transformer not in self._transformers:\n        self._transformers.$$$(transformer)"}
{"label":"append","msk":"def register_checker(self, checker):\n    \n    if checker not in self._checkers:\n        self._checkers.$$$(checker)\n        self.sort_checkers()","msk_intervention":"def register_checker(self, checker):\n    \n    if checker in self._checkers:\n        self._checkers.$$$(checker)\n        self.sort_checkers()"}
{"label":"remove","msk":"def unregister_checker(self, checker):\n    \n    if checker in self._checkers:\n        self._checkers.$$$(checker)","msk_intervention":"def unregister_checker(self, checker):\n    \n    if checker not in self._checkers:\n        self._checkers.$$$(checker)"}
{"label":"append","msk":"def uniq_stable(elems):\n    \n    unique = []\n    unique_dict = {}\n    for nn in elems:\n        if nn not in unique_dict:\n            unique.$$$(nn)\n            unique_dict[nn] = None\n    return unique","msk_intervention":"def uniq_stable(elems):\n    \n    unique = []\n    unique_dict = {}\n    for nn in elems:\n        if nn in unique_dict:\n            unique.$$$(nn)\n            unique_dict[nn] = None\n    return unique"}
